package org.matsim.parkingProxy;

import java.io.File;
import java.util.Collection;
import org.matsim.api.core.v01.population.Person;
import org.matsim.core.controler.events.AfterMobsimEvent;
import org.matsim.core.controler.events.BeforeMobsimEvent;
import org.matsim.core.controler.listener.AfterMobsimListener;
import org.matsim.core.controler.listener.BeforeMobsimListener;
import org.matsim.parkingProxy.penaltyCalculator.PenaltyCalculator;
import org.matsim.parkingProxy.penaltyCalculator.PenaltyFunction;
import org.matsim.parkingProxy.penaltyCalculator.PenaltyGenerator;
import org.matsim.parkingProxy.utils.AccessEgressFinder;
import org.matsim.parkingProxy.utils.AccessEgressFinder.LegActPair;

/**
 * <p>
 * This class allows to implicitly apply penalties to plans by changing the duration of the egress walk after car interactions.
 * By construction this only works for plans involving car trips and can not be used if you want to penalize all plans that
 * fulfill a certain condition.
 * </p>
 * <p>
 * More precisely, the class will... </br> 
 * 1. before the mobsim starts alter all egress walk durations depending on the spatial and temporal gridcell the walk starts in
 * and adapt the start time of the following activity accordingly. Since the egress walk is a teleported mode this translates 1:1
 * into a shorter activity time. The amount of penalty is defined by {@linkplain PenaltyCalculator} generated by the provided
 * {@linkplain PenaltyGenerator}. You probably want to reset and update the generator each iteration.</br>
 * 2. after the mobsim ends reverse the changes made in 1 so the evolutionary nature of MATSim is preserved.</br>
 * 3. do nothing during the scoring. Since the experienced plans are rated, the shortened activity durations resulting from the
 * longer egress walks already penalize the plan.</br>
 * 4. update the {@linkplain PenaltyCalculator} to the result of the last iteration. This has the side-effect that car trips are
 * not penalized by the metrics of the current iteration but by whichever the Generator has before the mobsim starts. However,
 * since only a small portion of the plans usually is changed, this should be okay (I hope...). In the zeroth iteration,
 * {@linkplain PenaltyCalculator#getDummyCalculator()} is used to calculate the penalties.
 * </p>
 * 
 * @author tkohl / Senozon
 *
 */
public class CarEgressWalkChanger implements BeforeMobsimListener, AfterMobsimListener {
	
	private static final String INSERTIONKEY = "[INSERTIONKEY]";
	public static final String OUTFILE_PENALTIES = "penalties_iter" + INSERTIONKEY + ".csv";
	public static final String CARMODE = "car";	
	
	private final PenaltyGenerator penaltyGenerator;
	private final PenaltyFunction penaltyFunction;
	private final AccessEgressFinder egressFinder = new AccessEgressFinder(CARMODE);
	
	private PenaltyCalculator penaltyCalculator;
	
	/**
	 * Sets the class up with the {@linkplain PenaltyCalculator.DefaultPenaltyFunction} and the specified {@linkplain PenaltyGenerator}.
	 * 
	 * @param penaltyGenerator
	 */
	public CarEgressWalkChanger(PenaltyGenerator penaltyGenerator) {
		this(penaltyGenerator, new PenaltyCalculator.DefaultPenaltyFunction());
	}
	
	/**
	 * Sets the class up with the specified {@linkplain PenaltyGenerator} and {@linkplain PenaltyFunction}.
	 * 
	 * @param penaltyGenerator
	 * @param penaltyFunction
	 */
	public CarEgressWalkChanger(PenaltyGenerator penaltyGenerator, PenaltyFunction penaltyFunction) {
		this.penaltyGenerator = penaltyGenerator;
		this.penaltyFunction = penaltyFunction;
	}

	/**
	 * gets a new {@linkplain PenaltyCalculator} and prolongs egress times
	 */
	@Override
	public void notifyBeforeMobsim(BeforeMobsimEvent event) {
		// first we need to update the Penalties to the result of the last iteration
		if (event.getIteration() == 0) {
			this.penaltyCalculator = PenaltyCalculator.getDummyCalculator();
		} else {
			this.penaltyCalculator = this.penaltyGenerator.generatePenaltyCalculator();
			this.penaltyCalculator.setPenaltyFunction(this.penaltyFunction);
			this.penaltyGenerator.reset();
		}
		this.penaltyCalculator.dump(new File(event.getServices().getConfig().controler().getOutputDirectory(),
				OUTFILE_PENALTIES.replace(INSERTIONKEY, Integer.toString(event.getIteration()))));
		
		// then we alter the egressWalk times according to the penalty
		this.changeEgressTimes(event.getServices().getScenario().getPopulation().getPersons().values(), false);
	}
	
	/**
	 * resets egress times before scoring / replanning
	 */
	@Override
	public void notifyAfterMobsim(AfterMobsimEvent event) {
		// we need to roll back the changes we made before the mobsim, otherwise we can't apply
		// a different penalty next iteration.
		this.changeEgressTimes(event.getServices().getScenario().getPopulation().getPersons().values(), true);
	}

	/**
	 * Changes the egress times of all agents using cars according to the penalty for the corresponding space-time-gridcell.
	 * 
	 * @param population All persons with their plan(s)
	 * @param reverse if {@code false}, the egress times get prolonged by the penalty time, if {@code true}, they get shortened
	 * by that time (calling this method twice, first with {@code false}, then with {@code true} should yield the original plans)
	 */
	private void changeEgressTimes(Collection<? extends Person> population, boolean reverse) {
		int sign = reverse ? -1 : 1;
		for (Person p : population) {
			for (LegActPair walkActPair : this.egressFinder.findEgressWalks(p.getSelectedPlan())) {
				double penalty = sign * this.penaltyCalculator.getPenalty(walkActPair.leg.getDepartureTime(), walkActPair.act.getCoord());
				walkActPair.leg.setTravelTime(walkActPair.leg.getTravelTime() + penalty);
				walkActPair.leg.getRoute().setTravelTime(walkActPair.leg.getRoute().getTravelTime() + penalty);
				walkActPair.act.setStartTime(walkActPair.act.getStartTime() + penalty);
			}
		}
	}

}
